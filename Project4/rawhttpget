#!/usr/bin/env python

from tcp import *
import sys
import socket
import time
import struct
from urlparse import urlparse

"""

NOTE: RUN THIS WITH '-w' FLAG AT THE END


Goals

1. Work on getting TCP to work over normal sockets. "SOCK_RAW/IPPROTO_TCP"
  - choose a valid local port
  - manage sequence and acknowledgement numbers
  - perform connection setup and tear-down
  - calculate offset and checksum in each packet
  - make sure incoming packets have valid checksums and in-order sequence numbers
  - quit after a few minutes (assume timeout)
  - stop and go--send one at a time, wait for ack, send next.
  - no need to consider RTT or RTO estimation, or congestion control
  - no need to consider some reliabilility: in-order delivery, 

  - advertized window in any way we choose

2. Then implement IP over a raw socket "SOCK_RAW/IPPROTO_RAW"
  - per packet
      - version
      - header length
      - total length
      - protocol identifier
      - checksum
  - can use OS APIs to query for IP of remote HTTP server (to handle DNS requests)
    as well as IP of source machine.
  - need to check for validity of received packet headers (remote IP? checksum? 
    protocol id?)
"""

src_port = 0
dest_port = 80
"""
hostname = sys.argv[1].split("http://").pop().split('/')[0]
if len(sys.argv[1].split('/')[1:]) > 0:
  path = '/' + '/'.join(sys.argv[1].split('/')[1:])
else:
  path = "/index.html"
"""

rawurl = sys.argv[1]

if "http" not in rawurl:
  rawurl = "http://" + rawurl

url = urlparse(rawurl)
print url
hostname = url.netloc
path = url.path

if len(path) == 0:
  path = "/index.html"

print "hostname: ", hostname
print "path: ", path


if len(sys.argv) > 2:
  from subprocess import call
  call(["wget", sys.argv[1]])

# hostname = "erictchin.com"
# :path ="/index.html"

# Get the requested page at given host
def get_page(host, link):
  # print "get page", link
  headers = """GET {link} HTTP/1.1
Host: {host}
Accept: text/html,application/xhtml+xml,application/xml


  """.format(link=link, host=host)
  reply = send(headers)

  if reply:
    print reply
  else:
    print "no data"
  # TODO: to get this to work, need to RECV data and return it via recv
  # Make sure that you receive a "200"
  """
  if reply == "":
    return ""
  print reply
  reply = reply.split("\r\n\r\n")

  if len(reply) > 1:
      print reply
      # return reply[1]

  else:
      pass # return ""
  check_status(reply[0])
  """

# Terminates program if error code is not 200 OK
def check_status( reply ):
    reply_l = reply.lower();

    if "200 ok" in reply_l:
        pass
    else:
        print "There was an error retrieving the page."

        sys.exit()

# Just send a message to the server and return the reply
def send(raw):
  s = Shoe()
  s.socket()
  s.connect((hostname, 80))

  #  time.sleep(1)

  s.send(raw)
  reply = s.recv()
  return reply

get_page(hostname, path)


def save_to_file(data):
  filename = path.split('/')[-1]
  fd = open(filename, "w")
  fd.write(data)

